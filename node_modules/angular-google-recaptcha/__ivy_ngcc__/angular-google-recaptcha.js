import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Injectable, InjectionToken, NgModule, NgZone, Optional, Output, Self, ViewChild } from '@angular/core';
import { NgControl } from '@angular/forms';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';

const _c0 = ["container"];
const RECAPTCHA_CONFIG = new InjectionToken('angular-google-recaptcha siteKey');

class ScriptLoaderService {
    /**
     * @param {?} config
     * @return {?}
     */
    injectAndLoadScript(config) {
        const /** @type {?} */ script = document.createElement('script');
        script.src = config.scriptSrc;
        script.async = true;
        script.defer = true;
        script.onload = () => config.onLoadCallback();
        script.onerror = err => config.onErrorCallback(err);
        document.body.appendChild(script);
    }
}
ScriptLoaderService.ɵfac = function ScriptLoaderService_Factory(t) { return new (t || ScriptLoaderService)(); };
ScriptLoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ScriptLoaderService, factory: ScriptLoaderService.ɵfac });
/**
 * @nocollapse
 */
ScriptLoaderService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ScriptLoaderService, [{
        type: Injectable
    }], null, null); })();
class RecaptchaComponent {
    /**
     * @param {?} recaptchaConfig
     * @param {?} controlDir
     * @param {?} scriptLoaderService
     * @param {?} zone
     * @param {?} cd
     */
    constructor(recaptchaConfig, controlDir, scriptLoaderService, zone, cd) {
        this.recaptchaConfig = recaptchaConfig;
        this.controlDir = controlDir;
        this.scriptLoaderService = scriptLoaderService;
        this.zone = zone;
        this.cd = cd;
        this.scriptLoad = new EventEmitter();
        this.scriptError = new EventEmitter();
        this.GLOBAL_ON_LOAD_CALLBACK_NAME = '___recaptchaOnLoadCallback___';
        this.controlDir.valueAccessor = this;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const /** @type {?} */ control = this.controlDir.control;
        if (!control) {
            return;
        }
        this.setGlobalHandlers();
        this.injectGoogleRecaptchaScript();
        /**
         * Only one validator (specifically our one below) makes sense for this Control, so we just overwrite
         * whatever was previously set
         */
        control.setValidators((ctrl) => {
            if (typeof this.activeRecaptchaId === 'undefined' || !this.recaptchaAPI) {
                return {
                    invalidRecaptcha: true,
                };
            }
            const /** @type {?} */ recaptchaResponse = this.recaptchaAPI.getResponse(this.activeRecaptchaId);
            if (!recaptchaResponse) {
                return {
                    invalidRecaptcha: true,
                };
            }
            return null;
        });
        control.updateValueAndValidity();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsetGlobalHandlers();
    }
    /**
     * There is currently no way to programmatically set the value of
     * a visible reCAPTCHA, so this is a noop
     * @param {?} val
     * @return {?}
     */
    writeValue(val) { }
    /**
     * Required method of the ControlValueAccessor interface, we register the callback
     * function that should be called whenever the model value changes
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Required method of the ControlValueAccessor interface, we register the callback
     * function that should be called whenever the control is "touched"
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Unfortunately we have to register a global handler for the onload
     * event from the recaptcha lib
     * @return {?}
     */
    setGlobalHandlers() {
        ((window))[this.GLOBAL_ON_LOAD_CALLBACK_NAME] = () => {
            /**
             * Make it easier to add type information to, and work with, the recaptcha lib
             * by storing a single reference to it
             */
            this.recaptchaAPI = ((window)).grecaptcha;
            this.renderRecaptcha();
        };
    }
    /**
     * @return {?}
     */
    unsetGlobalHandlers() {
        delete ((window))[this.GLOBAL_ON_LOAD_CALLBACK_NAME];
    }
    /**
     * Create a <script> element and inject it into the page in order
     * to load the recaptcha lib. Emit load or error events from the relevant
     * Outputs to the component
     * @return {?}
     */
    injectGoogleRecaptchaScript() {
        this.scriptLoaderService.injectAndLoadScript({
            scriptSrc: `https://www.google.com/recaptcha/api.js?render=explicit&onload=${this.GLOBAL_ON_LOAD_CALLBACK_NAME}`,
            onLoadCallback: () => this.scriptLoad.emit(),
            onErrorCallback: err => this.scriptError.emit(err),
        });
    }
    /**
     * Use the recaptcha lib to manually render a recaptcha widget with the ViewChild
     * container element, passing the relevant callbacks and configuration options
     * @return {?}
     */
    renderRecaptcha() {
        if (!this.recaptchaAPI) {
            return;
        }
        this.activeRecaptchaId = this.recaptchaAPI.render(this.container.nativeElement, {
            sitekey: this.recaptchaConfig.siteKey,
            callback: this.onRecaptchaValidCallback.bind(this),
            'expired-callback': this.onRecaptchaExpiredCallback.bind(this),
        });
    }
    /**
     * Handler which will be registered with the recaptcha lib to be called
     * whenever it has a valid status
     * @return {?}
     */
    onRecaptchaValidCallback() {
        this.zone.run(() => {
            this.onChange(true);
            this.onTouched();
            this.cd.markForCheck();
        });
    }
    /**
     * Handler which will be registered with the recaptcha lib to be called
     * whenever its valid status expires
     * @return {?}
     */
    onRecaptchaExpiredCallback() {
        this.zone.run(() => {
            this.onChange(false);
            this.cd.markForCheck();
        });
    }
}
RecaptchaComponent.ɵfac = function RecaptchaComponent_Factory(t) { return new (t || RecaptchaComponent)(ɵngcc0.ɵɵdirectiveInject(RECAPTCHA_CONFIG), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ScriptLoaderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
RecaptchaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: RecaptchaComponent, selectors: [["recaptcha"]], viewQuery: function RecaptchaComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
    } }, outputs: { scriptLoad: "scriptLoad", scriptError: "scriptError" }, features: [ɵngcc0.ɵɵProvidersFeature([ScriptLoaderService])], decls: 2, vars: 0, consts: [[1, "angular-google-recaptcha-container"], ["container", ""]], template: function RecaptchaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } }, encapsulation: 2, changeDetection: 0 });
/**
 * @nocollapse
 */
RecaptchaComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [RECAPTCHA_CONFIG,] },] },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional },] },
    { type: ScriptLoaderService, },
    { type: NgZone, },
    { type: ChangeDetectorRef, },
];
RecaptchaComponent.propDecorators = {
    'scriptLoad': [{ type: Output },],
    'scriptError': [{ type: Output },],
    'container': [{ type: ViewChild, args: ['container',] },],
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RecaptchaComponent, [{
        type: Component,
        args: [{
                selector: 'recaptcha',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div class="angular-google-recaptcha-container" #container></div>
  `,
                providers: [ScriptLoaderService]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [RECAPTCHA_CONFIG]
            }] }, { type: ɵngcc1.NgControl, decorators: [{
                type: Self
            }, {
                type: Optional
            }] }, { type: ScriptLoaderService }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { scriptLoad: [{
            type: Output
        }], scriptError: [{
            type: Output
        }], container: [{
            type: ViewChild,
            args: ['container']
        }] }); })();

class RecaptchaModule {
    /**
     * @param {?} recaptchaConfig
     * @return {?}
     */
    static forRoot(recaptchaConfig) {
        return {
            ngModule: RecaptchaModule,
            providers: [{ provide: RECAPTCHA_CONFIG, useValue: recaptchaConfig }],
        };
    }
}
RecaptchaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: RecaptchaModule });
RecaptchaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function RecaptchaModule_Factory(t) { return new (t || RecaptchaModule)(); } });
/**
 * @nocollapse
 */
RecaptchaModule.ctorParameters = () => [];
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(RecaptchaModule, { declarations: [RecaptchaComponent], exports: [RecaptchaComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(RecaptchaModule, [{
        type: NgModule,
        args: [{
                declarations: [RecaptchaComponent],
                exports: [RecaptchaComponent]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { RecaptchaModule, ScriptLoaderService, RecaptchaComponent, RECAPTCHA_CONFIG };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1nb29nbGUtcmVjYXB0Y2hhLmpzIiwic291cmNlcyI6WyJhbmd1bGFyLWdvb2dsZS1yZWNhcHRjaGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lIQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OzswQkFBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7aURBVUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MElBTUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7MEJBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIE5nTW9kdWxlLCBOZ1pvbmUsIE9wdGlvbmFsLCBPdXRwdXQsIFNlbGYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5jb25zdCBSRUNBUFRDSEFfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuKCdhbmd1bGFyLWdvb2dsZS1yZWNhcHRjaGEgc2l0ZUtleScpO1xuXG5jbGFzcyBTY3JpcHRMb2FkZXJTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgaW5qZWN0QW5kTG9hZFNjcmlwdChjb25maWcpIHtcbiAgICAgICAgY29uc3QgLyoqIEB0eXBlIHs/fSAqLyBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IGNvbmZpZy5zY3JpcHRTcmM7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiBjb25maWcub25Mb2FkQ2FsbGJhY2soKTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBlcnIgPT4gY29uZmlnLm9uRXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfVxufVxuU2NyaXB0TG9hZGVyU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuU2NyaXB0TG9hZGVyU2VydmljZS5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtdO1xuY2xhc3MgUmVjYXB0Y2hhQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2FwdGNoYUNvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gY29udHJvbERpclxuICAgICAqIEBwYXJhbSB7P30gc2NyaXB0TG9hZGVyU2VydmljZVxuICAgICAqIEBwYXJhbSB7P30gem9uZVxuICAgICAqIEBwYXJhbSB7P30gY2RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZWNhcHRjaGFDb25maWcsIGNvbnRyb2xEaXIsIHNjcmlwdExvYWRlclNlcnZpY2UsIHpvbmUsIGNkKSB7XG4gICAgICAgIHRoaXMucmVjYXB0Y2hhQ29uZmlnID0gcmVjYXB0Y2hhQ29uZmlnO1xuICAgICAgICB0aGlzLmNvbnRyb2xEaXIgPSBjb250cm9sRGlyO1xuICAgICAgICB0aGlzLnNjcmlwdExvYWRlclNlcnZpY2UgPSBzY3JpcHRMb2FkZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuc2NyaXB0TG9hZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zY3JpcHRFcnJvciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5HTE9CQUxfT05fTE9BRF9DQUxMQkFDS19OQU1FID0gJ19fX3JlY2FwdGNoYU9uTG9hZENhbGxiYWNrX19fJztcbiAgICAgICAgdGhpcy5jb250cm9sRGlyLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBjb25zdCAvKiogQHR5cGUgez99ICovIGNvbnRyb2wgPSB0aGlzLmNvbnRyb2xEaXIuY29udHJvbDtcbiAgICAgICAgaWYgKCFjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRHbG9iYWxIYW5kbGVycygpO1xuICAgICAgICB0aGlzLmluamVjdEdvb2dsZVJlY2FwdGNoYVNjcmlwdCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBvbmUgdmFsaWRhdG9yIChzcGVjaWZpY2FsbHkgb3VyIG9uZSBiZWxvdykgbWFrZXMgc2Vuc2UgZm9yIHRoaXMgQ29udHJvbCwgc28gd2UganVzdCBvdmVyd3JpdGVcbiAgICAgICAgICogd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2V0XG4gICAgICAgICAqL1xuICAgICAgICBjb250cm9sLnNldFZhbGlkYXRvcnMoKGN0cmwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hY3RpdmVSZWNhcHRjaGFJZCA9PT0gJ3VuZGVmaW5lZCcgfHwgIXRoaXMucmVjYXB0Y2hhQVBJKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJlY2FwdGNoYTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgLyoqIEB0eXBlIHs/fSAqLyByZWNhcHRjaGFSZXNwb25zZSA9IHRoaXMucmVjYXB0Y2hhQVBJLmdldFJlc3BvbnNlKHRoaXMuYWN0aXZlUmVjYXB0Y2hhSWQpO1xuICAgICAgICAgICAgaWYgKCFyZWNhcHRjaGFSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRSZWNhcHRjaGE6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zZXRHbG9iYWxIYW5kbGVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gd2F5IHRvIHByb2dyYW1tYXRpY2FsbHkgc2V0IHRoZSB2YWx1ZSBvZlxuICAgICAqIGEgdmlzaWJsZSByZUNBUFRDSEEsIHNvIHRoaXMgaXMgYSBub29wXG4gICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsKSB7IH1cbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCBtZXRob2Qgb2YgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSwgd2UgcmVnaXN0ZXIgdGhlIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBtb2RlbCB2YWx1ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIG1ldGhvZCBvZiB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlLCB3ZSByZWdpc3RlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbnRyb2wgaXMgXCJ0b3VjaGVkXCJcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmZvcnR1bmF0ZWx5IHdlIGhhdmUgdG8gcmVnaXN0ZXIgYSBnbG9iYWwgaGFuZGxlciBmb3IgdGhlIG9ubG9hZFxuICAgICAqIGV2ZW50IGZyb20gdGhlIHJlY2FwdGNoYSBsaWJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldEdsb2JhbEhhbmRsZXJzKCkge1xuICAgICAgICAoKHdpbmRvdykpW3RoaXMuR0xPQkFMX09OX0xPQURfQ0FMTEJBQ0tfTkFNRV0gPSAoKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1ha2UgaXQgZWFzaWVyIHRvIGFkZCB0eXBlIGluZm9ybWF0aW9uIHRvLCBhbmQgd29yayB3aXRoLCB0aGUgcmVjYXB0Y2hhIGxpYlxuICAgICAgICAgICAgICogYnkgc3RvcmluZyBhIHNpbmdsZSByZWZlcmVuY2UgdG8gaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZWNhcHRjaGFBUEkgPSAoKHdpbmRvdykpLmdyZWNhcHRjaGE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJlY2FwdGNoYSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHVuc2V0R2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgICAgIGRlbGV0ZSAoKHdpbmRvdykpW3RoaXMuR0xPQkFMX09OX0xPQURfQ0FMTEJBQ0tfTkFNRV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQgYW5kIGluamVjdCBpdCBpbnRvIHRoZSBwYWdlIGluIG9yZGVyXG4gICAgICogdG8gbG9hZCB0aGUgcmVjYXB0Y2hhIGxpYi4gRW1pdCBsb2FkIG9yIGVycm9yIGV2ZW50cyBmcm9tIHRoZSByZWxldmFudFxuICAgICAqIE91dHB1dHMgdG8gdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgaW5qZWN0R29vZ2xlUmVjYXB0Y2hhU2NyaXB0KCkge1xuICAgICAgICB0aGlzLnNjcmlwdExvYWRlclNlcnZpY2UuaW5qZWN0QW5kTG9hZFNjcmlwdCh7XG4gICAgICAgICAgICBzY3JpcHRTcmM6IGBodHRwczovL3d3dy5nb29nbGUuY29tL3JlY2FwdGNoYS9hcGkuanM/cmVuZGVyPWV4cGxpY2l0Jm9ubG9hZD0ke3RoaXMuR0xPQkFMX09OX0xPQURfQ0FMTEJBQ0tfTkFNRX1gLFxuICAgICAgICAgICAgb25Mb2FkQ2FsbGJhY2s6ICgpID0+IHRoaXMuc2NyaXB0TG9hZC5lbWl0KCksXG4gICAgICAgICAgICBvbkVycm9yQ2FsbGJhY2s6IGVyciA9PiB0aGlzLnNjcmlwdEVycm9yLmVtaXQoZXJyKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0aGUgcmVjYXB0Y2hhIGxpYiB0byBtYW51YWxseSByZW5kZXIgYSByZWNhcHRjaGEgd2lkZ2V0IHdpdGggdGhlIFZpZXdDaGlsZFxuICAgICAqIGNvbnRhaW5lciBlbGVtZW50LCBwYXNzaW5nIHRoZSByZWxldmFudCBjYWxsYmFja3MgYW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgcmVuZGVyUmVjYXB0Y2hhKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVjYXB0Y2hhQVBJKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVSZWNhcHRjaGFJZCA9IHRoaXMucmVjYXB0Y2hhQVBJLnJlbmRlcih0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCB7XG4gICAgICAgICAgICBzaXRla2V5OiB0aGlzLnJlY2FwdGNoYUNvbmZpZy5zaXRlS2V5LFxuICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMub25SZWNhcHRjaGFWYWxpZENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgICAgICAnZXhwaXJlZC1jYWxsYmFjayc6IHRoaXMub25SZWNhcHRjaGFFeHBpcmVkQ2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgd2hpY2ggd2lsbCBiZSByZWdpc3RlcmVkIHdpdGggdGhlIHJlY2FwdGNoYSBsaWIgdG8gYmUgY2FsbGVkXG4gICAgICogd2hlbmV2ZXIgaXQgaGFzIGEgdmFsaWQgc3RhdHVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBvblJlY2FwdGNoYVZhbGlkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlciB3aGljaCB3aWxsIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgcmVjYXB0Y2hhIGxpYiB0byBiZSBjYWxsZWRcbiAgICAgKiB3aGVuZXZlciBpdHMgdmFsaWQgc3RhdHVzIGV4cGlyZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIG9uUmVjYXB0Y2hhRXhwaXJlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuUmVjYXB0Y2hhQ29tcG9uZW50LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdyZWNhcHRjaGEnLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImFuZ3VsYXItZ29vZ2xlLXJlY2FwdGNoYS1jb250YWluZXJcIiAjY29udGFpbmVyPjwvZGl2PlxuICBgLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NjcmlwdExvYWRlclNlcnZpY2VdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5SZWNhcHRjaGFDb21wb25lbnQuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW1JFQ0FQVENIQV9DT05GSUcsXSB9LF0gfSxcbiAgICB7IHR5cGU6IE5nQ29udHJvbCwgZGVjb3JhdG9yczogW3sgdHlwZTogU2VsZiB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogU2NyaXB0TG9hZGVyU2VydmljZSwgfSxcbiAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICB7IHR5cGU6IENoYW5nZURldGVjdG9yUmVmLCB9LFxuXTtcblJlY2FwdGNoYUNvbXBvbmVudC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAnc2NyaXB0TG9hZCc6IFt7IHR5cGU6IE91dHB1dCB9LF0sXG4gICAgJ3NjcmlwdEVycm9yJzogW3sgdHlwZTogT3V0cHV0IH0sXSxcbiAgICAnY29udGFpbmVyJzogW3sgdHlwZTogVmlld0NoaWxkLCBhcmdzOiBbJ2NvbnRhaW5lcicsXSB9LF0sXG59O1xuXG5jbGFzcyBSZWNhcHRjaGFNb2R1bGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjYXB0Y2hhQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yUm9vdChyZWNhcHRjaGFDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBSZWNhcHRjaGFNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFJFQ0FQVENIQV9DT05GSUcsIHVzZVZhbHVlOiByZWNhcHRjaGFDb25maWcgfV0sXG4gICAgICAgIH07XG4gICAgfVxufVxuUmVjYXB0Y2hhTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtSZWNhcHRjaGFDb21wb25lbnRdLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtSZWNhcHRjaGFDb21wb25lbnRdLFxuICAgICAgICAgICAgfSxdIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5SZWNhcHRjaGFNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBSZWNhcHRjaGFNb2R1bGUsIFNjcmlwdExvYWRlclNlcnZpY2UsIFJlY2FwdGNoYUNvbXBvbmVudCwgUkVDQVBUQ0hBX0NPTkZJRyB9O1xuIl19
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Injectable, InjectionToken, NgModule, NgZone, Optional, Output, Self, ViewChild } from '@angular/core';
import { NgControl } from '@angular/forms';

var RECAPTCHA_CONFIG = new InjectionToken('angular-google-recaptcha siteKey');

var ScriptLoaderService = /** @class */ (function () {
    function ScriptLoaderService() {
    }
    /**
     * @param {?} config
     * @return {?}
     */
    ScriptLoaderService.prototype.injectAndLoadScript = function (config) {
        var /** @type {?} */ script = document.createElement('script');
        script.src = config.scriptSrc;
        script.async = true;
        script.defer = true;
        script.onload = function () { return config.onLoadCallback(); };
        script.onerror = function (err) { return config.onErrorCallback(err); };
        document.body.appendChild(script);
    };
    ScriptLoaderService.decorators = [
        { type: Injectable },
    ];
    /**
     * @nocollapse
     */
    ScriptLoaderService.ctorParameters = function () { return []; };
    return ScriptLoaderService;
}());
var RecaptchaComponent = /** @class */ (function () {
    /**
     * @param {?} recaptchaConfig
     * @param {?} controlDir
     * @param {?} scriptLoaderService
     * @param {?} zone
     * @param {?} cd
     */
    function RecaptchaComponent(recaptchaConfig, controlDir, scriptLoaderService, zone, cd) {
        this.recaptchaConfig = recaptchaConfig;
        this.controlDir = controlDir;
        this.scriptLoaderService = scriptLoaderService;
        this.zone = zone;
        this.cd = cd;
        this.scriptLoad = new EventEmitter();
        this.scriptError = new EventEmitter();
        this.GLOBAL_ON_LOAD_CALLBACK_NAME = '___recaptchaOnLoadCallback___';
        this.controlDir.valueAccessor = this;
    }
    /**
     * @return {?}
     */
    RecaptchaComponent.prototype.ngOnInit = function () {
        var _this = this;
        var /** @type {?} */ control = this.controlDir.control;
        if (!control) {
            return;
        }
        this.setGlobalHandlers();
        this.injectGoogleRecaptchaScript();
        /**
         * Only one validator (specifically our one below) makes sense for this Control, so we just overwrite
         * whatever was previously set
         */
        control.setValidators(function (ctrl) {
            if (typeof _this.activeRecaptchaId === 'undefined' || !_this.recaptchaAPI) {
                return {
                    invalidRecaptcha: true,
                };
            }
            var /** @type {?} */ recaptchaResponse = _this.recaptchaAPI.getResponse(_this.activeRecaptchaId);
            if (!recaptchaResponse) {
                return {
                    invalidRecaptcha: true,
                };
            }
            return null;
        });
        control.updateValueAndValidity();
    };
    /**
     * @return {?}
     */
    RecaptchaComponent.prototype.ngOnDestroy = function () {
        this.unsetGlobalHandlers();
    };
    /**
     * There is currently no way to programmatically set the value of
     * a visible reCAPTCHA, so this is a noop
     * @param {?} val
     * @return {?}
     */
    RecaptchaComponent.prototype.writeValue = function (val) { };
    /**
     * Required method of the ControlValueAccessor interface, we register the callback
     * function that should be called whenever the model value changes
     * @param {?} fn
     * @return {?}
     */
    RecaptchaComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    /**
     * Required method of the ControlValueAccessor interface, we register the callback
     * function that should be called whenever the control is "touched"
     * @param {?} fn
     * @return {?}
     */
    RecaptchaComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    /**
     * Unfortunately we have to register a global handler for the onload
     * event from the recaptcha lib
     * @return {?}
     */
    RecaptchaComponent.prototype.setGlobalHandlers = function () {
        var _this = this;
        ((window))[this.GLOBAL_ON_LOAD_CALLBACK_NAME] = function () {
            /**
             * Make it easier to add type information to, and work with, the recaptcha lib
             * by storing a single reference to it
             */
            _this.recaptchaAPI = ((window)).grecaptcha;
            _this.renderRecaptcha();
        };
    };
    /**
     * @return {?}
     */
    RecaptchaComponent.prototype.unsetGlobalHandlers = function () {
        delete ((window))[this.GLOBAL_ON_LOAD_CALLBACK_NAME];
    };
    /**
     * Create a <script> element and inject it into the page in order
     * to load the recaptcha lib. Emit load or error events from the relevant
     * Outputs to the component
     * @return {?}
     */
    RecaptchaComponent.prototype.injectGoogleRecaptchaScript = function () {
        var _this = this;
        this.scriptLoaderService.injectAndLoadScript({
            scriptSrc: "https://www.google.com/recaptcha/api.js?render=explicit&onload=" + this.GLOBAL_ON_LOAD_CALLBACK_NAME,
            onLoadCallback: function () { return _this.scriptLoad.emit(); },
            onErrorCallback: function (err) { return _this.scriptError.emit(err); },
        });
    };
    /**
     * Use the recaptcha lib to manually render a recaptcha widget with the ViewChild
     * container element, passing the relevant callbacks and configuration options
     * @return {?}
     */
    RecaptchaComponent.prototype.renderRecaptcha = function () {
        if (!this.recaptchaAPI) {
            return;
        }
        this.activeRecaptchaId = this.recaptchaAPI.render(this.container.nativeElement, {
            sitekey: this.recaptchaConfig.siteKey,
            callback: this.onRecaptchaValidCallback.bind(this),
            'expired-callback': this.onRecaptchaExpiredCallback.bind(this),
        });
    };
    /**
     * Handler which will be registered with the recaptcha lib to be called
     * whenever it has a valid status
     * @return {?}
     */
    RecaptchaComponent.prototype.onRecaptchaValidCallback = function () {
        var _this = this;
        this.zone.run(function () {
            _this.onChange(true);
            _this.onTouched();
            _this.cd.markForCheck();
        });
    };
    /**
     * Handler which will be registered with the recaptcha lib to be called
     * whenever its valid status expires
     * @return {?}
     */
    RecaptchaComponent.prototype.onRecaptchaExpiredCallback = function () {
        var _this = this;
        this.zone.run(function () {
            _this.onChange(false);
            _this.cd.markForCheck();
        });
    };
    RecaptchaComponent.decorators = [
        { type: Component, args: [{
                    selector: 'recaptcha',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: "\n    <div class=\"angular-google-recaptcha-container\" #container></div>\n  ",
                    providers: [ScriptLoaderService],
                },] },
    ];
    /**
     * @nocollapse
     */
    RecaptchaComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [RECAPTCHA_CONFIG,] },] },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional },] },
        { type: ScriptLoaderService, },
        { type: NgZone, },
        { type: ChangeDetectorRef, },
    ]; };
    RecaptchaComponent.propDecorators = {
        'scriptLoad': [{ type: Output },],
        'scriptError': [{ type: Output },],
        'container': [{ type: ViewChild, args: ['container',] },],
    };
    return RecaptchaComponent;
}());

var RecaptchaModule = /** @class */ (function () {
    function RecaptchaModule() {
    }
    /**
     * @param {?} recaptchaConfig
     * @return {?}
     */
    RecaptchaModule.forRoot = function (recaptchaConfig) {
        return {
            ngModule: RecaptchaModule,
            providers: [{ provide: RECAPTCHA_CONFIG, useValue: recaptchaConfig }],
        };
    };
    RecaptchaModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [RecaptchaComponent],
                    exports: [RecaptchaComponent],
                },] },
    ];
    /**
     * @nocollapse
     */
    RecaptchaModule.ctorParameters = function () { return []; };
    return RecaptchaModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { RecaptchaModule, ScriptLoaderService, RecaptchaComponent, RECAPTCHA_CONFIG };

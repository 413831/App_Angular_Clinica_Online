import { OnInit } from '@angular/core';
/**
 * AgmPolylineIcon enables to add polyline sequences to add arrows, circle,
 * or custom icons either along the entire line, or in a specific part of it.
 * See https://developers.google.com/maps/documentation/javascript/shapes#polyline_customize
 *
 * ### Example
 * ```html
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polyline>
 *          <agm-icon-sequence [fixedRotation]="true" [path]="'FORWARD_OPEN_ARROW'">
 *          </agm-icon-sequence>
 *      </agm-polyline>
 *    </agm-map>
 * ```
 *
 * @export
 * @class AgmPolylineIcon
 */
import * as ɵngcc0 from '@angular/core';
export declare class AgmPolylineIcon implements OnInit {
    /**
     * If `true`, each icon in the sequence has the same fixed rotation regardless of the
     * angle of the edge on which it lies. Defaults to `false`, in which case each icon
     * in the sequence is rotated to align with its edge.
     *
     * @type {boolean}
     * @memberof AgmPolylineIcon
     */
    fixedRotation: boolean;
    /**
     * The distance from the start of the line at which an icon is to be rendered. This
     * distance may be expressed as a percentage of line's length (e.g. '50%') or in pixels
     * (e.g. '50px'). Defaults to '100%'.
     *
     * @type {string}
     * @memberof AgmPolylineIcon
     */
    offset: string;
    /**
     * The distance between consecutive icons on the line. This distance may be expressed as
     * a percentage of the line's length (e.g. '50%') or in pixels (e.g. '50px'). To disable
     * repeating of the icon, specify '0'. Defaults to '0'.
     *
     * @type {string}
     * @memberof AgmPolylineIcon
     */
    repeat: string;
    /**
     * The x coordinate of the position of the symbol relative to the polyline. The coordinate
     * of the symbol's path is translated _left_ by the anchor's x coordinate. By default, a
     * symbol is anchored at (0, 0). The position is expressed in the same coordinate system as the
     * symbol's path.
     *
     * @type {number}
     * @memberof AgmPolylineIcon
     */
    anchorX: number;
    /**
     * The y coordinate of the position of the symbol relative to the polyline. The coordinate
     * of the symbol's path is translated _up_ by the anchor's y coordinate. By default, a
     * symbol is anchored at (0, 0). The position is expressed in the same coordinate system as the
     * symbol's path.
     *
     * @type {number}
     * @memberof AgmPolylineIcon
     */
    anchorY: number;
    /**
     * The symbol's fill color. All CSS3 colors are supported except for extended named
     * colors. Defaults to the stroke color of the corresponding polyline.
     *
     * @type {string}
     * @memberof AgmPolylineIcon
     */
    fillColor: string;
    /**
     * The symbol's fill opacity. Defaults to 0.
     */
    fillOpacity: number;
    /**
     * The symbol's path, which is a built-in symbol path, or a custom path expressed using
     * SVG path notation. Required.
     *
     * @type {SymbolPath}
     * @memberof AgmPolylineIcon
     */
    path: 'CIRCLE' | 'BACKWARD_CLOSED_ARROW' | 'BACKWARD_OPEN_ARROW' | 'FORWARD_CLOSED_ARROW' | 'FORWARD_OPEN_ARROW' | string;
    /**
     * The angle by which to rotate the symbol, expressed clockwise in degrees.
     * Defaults to 0. A symbol where `fixedRotation` is `false` is rotated relative to
     * the angle of the edge on which it lies.
     *
     * @type {number}
     * @memberof AgmPolylineIcon
     */
    rotation: number;
    /**
     * The amount by which the symbol is scaled in size. Defaults to the stroke weight
     * of the polyline; after scaling, the symbol must lie inside a square 22 pixels in
     * size centered at the symbol's anchor.
     *
     * @type {number}
     * @memberof AgmPolylineIcon
     */
    scale: number;
    /**
     * The symbol's stroke color. All CSS3 colors are supported except for extended named
     * colors. Defaults to the stroke color of the polyline.
     *
     * @type {string}
     * @memberof AgmPolylineIcon
     */
    strokeColor: string;
    /**
     * The symbol's stroke opacity. Defaults to the stroke opacity of the polyline.
     *
     * @type {number}
     * @memberof AgmPolylineIcon
     */
    strokeOpacity: number;
    /**
     * The symbol's stroke weight. Defaults to the scale of the symbol.
     *
     * @type {number}
     * @memberof AgmPolylineIcon
     */
    strokeWeight: number;
    ngOnInit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmPolylineIcon, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmPolylineIcon, "agm-polyline agm-icon-sequence", never, { "fixedRotation": "fixedRotation"; "offset": "offset"; "repeat": "repeat"; "anchorX": "anchorX"; "anchorY": "anchorY"; "fillColor": "fillColor"; "fillOpacity": "fillOpacity"; "path": "path"; "rotation": "rotation"; "scale": "scale"; "strokeColor": "strokeColor"; "strokeOpacity": "strokeOpacity"; "strokeWeight": "strokeWeight"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9seWxpbmUtaWNvbi5kLnRzIiwic291cmNlcyI6WyJwb2x5bGluZS1pY29uLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4vKipcbiAqIEFnbVBvbHlsaW5lSWNvbiBlbmFibGVzIHRvIGFkZCBwb2x5bGluZSBzZXF1ZW5jZXMgdG8gYWRkIGFycm93cywgY2lyY2xlLFxuICogb3IgY3VzdG9tIGljb25zIGVpdGhlciBhbG9uZyB0aGUgZW50aXJlIGxpbmUsIG9yIGluIGEgc3BlY2lmaWMgcGFydCBvZiBpdC5cbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9zaGFwZXMjcG9seWxpbmVfY3VzdG9taXplXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqICAgIDxhZ20tbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPGFnbS1wb2x5bGluZT5cbiAqICAgICAgICAgIDxhZ20taWNvbi1zZXF1ZW5jZSBbZml4ZWRSb3RhdGlvbl09XCJ0cnVlXCIgW3BhdGhdPVwiJ0ZPUldBUkRfT1BFTl9BUlJPVydcIj5cbiAqICAgICAgICAgIDwvYWdtLWljb24tc2VxdWVuY2U+XG4gKiAgICAgIDwvYWdtLXBvbHlsaW5lPlxuICogICAgPC9hZ20tbWFwPlxuICogYGBgXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIEFnbVBvbHlsaW5lSWNvblxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21Qb2x5bGluZUljb24gaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgZWFjaCBpY29uIGluIHRoZSBzZXF1ZW5jZSBoYXMgdGhlIHNhbWUgZml4ZWQgcm90YXRpb24gcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiBhbmdsZSBvZiB0aGUgZWRnZSBvbiB3aGljaCBpdCBsaWVzLiBEZWZhdWx0cyB0byBgZmFsc2VgLCBpbiB3aGljaCBjYXNlIGVhY2ggaWNvblxuICAgICAqIGluIHRoZSBzZXF1ZW5jZSBpcyByb3RhdGVkIHRvIGFsaWduIHdpdGggaXRzIGVkZ2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyb2YgQWdtUG9seWxpbmVJY29uXG4gICAgICovXG4gICAgZml4ZWRSb3RhdGlvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgYXQgd2hpY2ggYW4gaWNvbiBpcyB0byBiZSByZW5kZXJlZC4gVGhpc1xuICAgICAqIGRpc3RhbmNlIG1heSBiZSBleHByZXNzZWQgYXMgYSBwZXJjZW50YWdlIG9mIGxpbmUncyBsZW5ndGggKGUuZy4gJzUwJScpIG9yIGluIHBpeGVsc1xuICAgICAqIChlLmcuICc1MHB4JykuIERlZmF1bHRzIHRvICcxMDAlJy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIEFnbVBvbHlsaW5lSWNvblxuICAgICAqL1xuICAgIG9mZnNldDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGljb25zIG9uIHRoZSBsaW5lLiBUaGlzIGRpc3RhbmNlIG1heSBiZSBleHByZXNzZWQgYXNcbiAgICAgKiBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGxpbmUncyBsZW5ndGggKGUuZy4gJzUwJScpIG9yIGluIHBpeGVscyAoZS5nLiAnNTBweCcpLiBUbyBkaXNhYmxlXG4gICAgICogcmVwZWF0aW5nIG9mIHRoZSBpY29uLCBzcGVjaWZ5ICcwJy4gRGVmYXVsdHMgdG8gJzAnLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgQWdtUG9seWxpbmVJY29uXG4gICAgICovXG4gICAgcmVwZWF0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcG9zaXRpb24gb2YgdGhlIHN5bWJvbCByZWxhdGl2ZSB0byB0aGUgcG9seWxpbmUuIFRoZSBjb29yZGluYXRlXG4gICAgICogb2YgdGhlIHN5bWJvbCdzIHBhdGggaXMgdHJhbnNsYXRlZCBfbGVmdF8gYnkgdGhlIGFuY2hvcidzIHggY29vcmRpbmF0ZS4gQnkgZGVmYXVsdCwgYVxuICAgICAqIHN5bWJvbCBpcyBhbmNob3JlZCBhdCAoMCwgMCkuIFRoZSBwb3NpdGlvbiBpcyBleHByZXNzZWQgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0gYXMgdGhlXG4gICAgICogc3ltYm9sJ3MgcGF0aC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIEFnbVBvbHlsaW5lSWNvblxuICAgICAqL1xuICAgIGFuY2hvclg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3ltYm9sIHJlbGF0aXZlIHRvIHRoZSBwb2x5bGluZS4gVGhlIGNvb3JkaW5hdGVcbiAgICAgKiBvZiB0aGUgc3ltYm9sJ3MgcGF0aCBpcyB0cmFuc2xhdGVkIF91cF8gYnkgdGhlIGFuY2hvcidzIHkgY29vcmRpbmF0ZS4gQnkgZGVmYXVsdCwgYVxuICAgICAqIHN5bWJvbCBpcyBhbmNob3JlZCBhdCAoMCwgMCkuIFRoZSBwb3NpdGlvbiBpcyBleHByZXNzZWQgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZSBzeXN0ZW0gYXMgdGhlXG4gICAgICogc3ltYm9sJ3MgcGF0aC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIEFnbVBvbHlsaW5lSWNvblxuICAgICAqL1xuICAgIGFuY2hvclk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sJ3MgZmlsbCBjb2xvci4gQWxsIENTUzMgY29sb3JzIGFyZSBzdXBwb3J0ZWQgZXhjZXB0IGZvciBleHRlbmRlZCBuYW1lZFxuICAgICAqIGNvbG9ycy4gRGVmYXVsdHMgdG8gdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY29ycmVzcG9uZGluZyBwb2x5bGluZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlcm9mIEFnbVBvbHlsaW5lSWNvblxuICAgICAqL1xuICAgIGZpbGxDb2xvcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBzeW1ib2wncyBmaWxsIG9wYWNpdHkuIERlZmF1bHRzIHRvIDAuXG4gICAgICovXG4gICAgZmlsbE9wYWNpdHk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sJ3MgcGF0aCwgd2hpY2ggaXMgYSBidWlsdC1pbiBzeW1ib2wgcGF0aCwgb3IgYSBjdXN0b20gcGF0aCBleHByZXNzZWQgdXNpbmdcbiAgICAgKiBTVkcgcGF0aCBub3RhdGlvbi4gUmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3ltYm9sUGF0aH1cbiAgICAgKiBAbWVtYmVyb2YgQWdtUG9seWxpbmVJY29uXG4gICAgICovXG4gICAgcGF0aDogJ0NJUkNMRScgfCAnQkFDS1dBUkRfQ0xPU0VEX0FSUk9XJyB8ICdCQUNLV0FSRF9PUEVOX0FSUk9XJyB8ICdGT1JXQVJEX0NMT1NFRF9BUlJPVycgfCAnRk9SV0FSRF9PUEVOX0FSUk9XJyB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgYW5nbGUgYnkgd2hpY2ggdG8gcm90YXRlIHRoZSBzeW1ib2wsIGV4cHJlc3NlZCBjbG9ja3dpc2UgaW4gZGVncmVlcy5cbiAgICAgKiBEZWZhdWx0cyB0byAwLiBBIHN5bWJvbCB3aGVyZSBgZml4ZWRSb3RhdGlvbmAgaXMgYGZhbHNlYCBpcyByb3RhdGVkIHJlbGF0aXZlIHRvXG4gICAgICogdGhlIGFuZ2xlIG9mIHRoZSBlZGdlIG9uIHdoaWNoIGl0IGxpZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBBZ21Qb2x5bGluZUljb25cbiAgICAgKi9cbiAgICByb3RhdGlvbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIHN5bWJvbCBpcyBzY2FsZWQgaW4gc2l6ZS4gRGVmYXVsdHMgdG8gdGhlIHN0cm9rZSB3ZWlnaHRcbiAgICAgKiBvZiB0aGUgcG9seWxpbmU7IGFmdGVyIHNjYWxpbmcsIHRoZSBzeW1ib2wgbXVzdCBsaWUgaW5zaWRlIGEgc3F1YXJlIDIyIHBpeGVscyBpblxuICAgICAqIHNpemUgY2VudGVyZWQgYXQgdGhlIHN5bWJvbCdzIGFuY2hvci5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIEFnbVBvbHlsaW5lSWNvblxuICAgICAqL1xuICAgIHNjYWxlOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCdzIHN0cm9rZSBjb2xvci4gQWxsIENTUzMgY29sb3JzIGFyZSBzdXBwb3J0ZWQgZXhjZXB0IGZvciBleHRlbmRlZCBuYW1lZFxuICAgICAqIGNvbG9ycy4gRGVmYXVsdHMgdG8gdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgcG9seWxpbmUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJvZiBBZ21Qb2x5bGluZUljb25cbiAgICAgKi9cbiAgICBzdHJva2VDb2xvcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBzeW1ib2wncyBzdHJva2Ugb3BhY2l0eS4gRGVmYXVsdHMgdG8gdGhlIHN0cm9rZSBvcGFjaXR5IG9mIHRoZSBwb2x5bGluZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlcm9mIEFnbVBvbHlsaW5lSWNvblxuICAgICAqL1xuICAgIHN0cm9rZU9wYWNpdHk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sJ3Mgc3Ryb2tlIHdlaWdodC4gRGVmYXVsdHMgdG8gdGhlIHNjYWxlIG9mIHRoZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJvZiBBZ21Qb2x5bGluZUljb25cbiAgICAgKi9cbiAgICBzdHJva2VXZWlnaHQ6IG51bWJlcjtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xufVxuIl19
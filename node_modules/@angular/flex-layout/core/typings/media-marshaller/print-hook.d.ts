/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OnDestroy } from '@angular/core';
import { MediaChange } from '../media-change';
import { BreakPoint } from '../breakpoints/break-point';
import { LayoutConfigOptions } from '../tokens/library-config';
import { BreakPointRegistry, OptionalBreakPoint } from '../breakpoints/break-point-registry';
/**
 * Interface to apply PrintHook to call anonymous `target.updateStyles()`
 */
import * as ɵngcc0 from '@angular/core';
export interface HookTarget {
    activatedBreakpoints: BreakPoint[];
    updateStyles(): void;
}
export declare const BREAKPOINT_PRINT: {
    alias: string;
    mediaQuery: string;
    priority: number;
};
/**
 * PrintHook - Use to intercept print MediaQuery activations and force
 *             layouts to render with the specified print alias/breakpoint
 *
 * Used in MediaMarshaller and MediaObserver
 */
export declare class PrintHook implements OnDestroy {
    protected breakpoints: BreakPointRegistry;
    protected layoutConfig: LayoutConfigOptions;
    protected _document: any;
    constructor(breakpoints: BreakPointRegistry, layoutConfig: LayoutConfigOptions, _document: any);
    /** Add 'print' mediaQuery: to listen for matchMedia activations */
    withPrintQuery(queries: string[]): string[];
    /** Is the MediaChange event for any 'print' @media */
    isPrintEvent(e: MediaChange): Boolean;
    /** What is the desired mqAlias to use while printing? */
    get printAlias(): string[];
    /** Lookup breakpoints associated with print aliases. */
    get printBreakPoints(): BreakPoint[];
    /** Lookup breakpoint associated with mediaQuery */
    getEventBreakpoints({ mediaQuery }: MediaChange): BreakPoint[];
    /** Update event with printAlias mediaQuery information */
    updateEvent(event: MediaChange): MediaChange;
    private registeredBeforeAfterPrintHooks;
    private isPrintingBeforeAfterEvent;
    private beforePrintEventListeners;
    private afterPrintEventListeners;
    private registerBeforeAfterPrintHooks;
    /**
     * Prepare RxJS filter operator with partial application
     * @return pipeable filter predicate
     */
    interceptEvents(target: HookTarget): (event: MediaChange) => void;
    /** Stop mediaChange event propagation in event streams */
    blockPropagation(): (event: MediaChange) => boolean;
    /**
     * Save current activateBreakpoints (for later restore)
     * and substitute only the printAlias breakpoint
     */
    protected startPrinting(target: HookTarget, bpList: OptionalBreakPoint[]): void;
    /** For any print de-activations, reset the entire print queue */
    protected stopPrinting(target: HookTarget): void;
    /**
     * To restore pre-Print Activations, we must capture the proper
     * list of breakpoint activations BEFORE print starts. OnBeforePrint()
     * is supported; so 'print' mediaQuery activations are used as a fallback
     * in browsers without `beforeprint` support.
     *
     * >  But activated breakpoints are deactivated BEFORE 'print' activation.
     *
     * Let's capture all de-activations using the following logic:
     *
     *  When not printing:
     *    - clear cache when activating non-print breakpoint
     *    - update cache (and sort) when deactivating
     *
     *  When printing:
     *    - sort and save when starting print
     *    - restore as activatedTargets and clear when stop printing
     */
    collectActivations(event: MediaChange): void;
    /** Teardown logic for the service. */
    ngOnDestroy(): void;
    /** Is this service currently in Print-mode ? */
    private isPrinting;
    private queue;
    private deactivations;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PrintHook, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJpbnQtaG9vay5kLnRzIiwic291cmNlcyI6WyJwcmludC1ob29rLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1lZGlhQ2hhbmdlIH0gZnJvbSAnLi4vbWVkaWEtY2hhbmdlJztcbmltcG9ydCB7IEJyZWFrUG9pbnQgfSBmcm9tICcuLi9icmVha3BvaW50cy9icmVhay1wb2ludCc7XG5pbXBvcnQgeyBMYXlvdXRDb25maWdPcHRpb25zIH0gZnJvbSAnLi4vdG9rZW5zL2xpYnJhcnktY29uZmlnJztcbmltcG9ydCB7IEJyZWFrUG9pbnRSZWdpc3RyeSwgT3B0aW9uYWxCcmVha1BvaW50IH0gZnJvbSAnLi4vYnJlYWtwb2ludHMvYnJlYWstcG9pbnQtcmVnaXN0cnknO1xuLyoqXG4gKiBJbnRlcmZhY2UgdG8gYXBwbHkgUHJpbnRIb29rIHRvIGNhbGwgYW5vbnltb3VzIGB0YXJnZXQudXBkYXRlU3R5bGVzKClgXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG9va1RhcmdldCB7XG4gICAgYWN0aXZhdGVkQnJlYWtwb2ludHM6IEJyZWFrUG9pbnRbXTtcbiAgICB1cGRhdGVTdHlsZXMoKTogdm9pZDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IEJSRUFLUE9JTlRfUFJJTlQ6IHtcbiAgICBhbGlhczogc3RyaW5nO1xuICAgIG1lZGlhUXVlcnk6IHN0cmluZztcbiAgICBwcmlvcml0eTogbnVtYmVyO1xufTtcbi8qKlxuICogUHJpbnRIb29rIC0gVXNlIHRvIGludGVyY2VwdCBwcmludCBNZWRpYVF1ZXJ5IGFjdGl2YXRpb25zIGFuZCBmb3JjZVxuICogICAgICAgICAgICAgbGF5b3V0cyB0byByZW5kZXIgd2l0aCB0aGUgc3BlY2lmaWVkIHByaW50IGFsaWFzL2JyZWFrcG9pbnRcbiAqXG4gKiBVc2VkIGluIE1lZGlhTWFyc2hhbGxlciBhbmQgTWVkaWFPYnNlcnZlclxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQcmludEhvb2sgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByb3RlY3RlZCBicmVha3BvaW50czogQnJlYWtQb2ludFJlZ2lzdHJ5O1xuICAgIHByb3RlY3RlZCBsYXlvdXRDb25maWc6IExheW91dENvbmZpZ09wdGlvbnM7XG4gICAgcHJvdGVjdGVkIF9kb2N1bWVudDogYW55O1xuICAgIGNvbnN0cnVjdG9yKGJyZWFrcG9pbnRzOiBCcmVha1BvaW50UmVnaXN0cnksIGxheW91dENvbmZpZzogTGF5b3V0Q29uZmlnT3B0aW9ucywgX2RvY3VtZW50OiBhbnkpO1xuICAgIC8qKiBBZGQgJ3ByaW50JyBtZWRpYVF1ZXJ5OiB0byBsaXN0ZW4gZm9yIG1hdGNoTWVkaWEgYWN0aXZhdGlvbnMgKi9cbiAgICB3aXRoUHJpbnRRdWVyeShxdWVyaWVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdO1xuICAgIC8qKiBJcyB0aGUgTWVkaWFDaGFuZ2UgZXZlbnQgZm9yIGFueSAncHJpbnQnIEBtZWRpYSAqL1xuICAgIGlzUHJpbnRFdmVudChlOiBNZWRpYUNoYW5nZSk6IEJvb2xlYW47XG4gICAgLyoqIFdoYXQgaXMgdGhlIGRlc2lyZWQgbXFBbGlhcyB0byB1c2Ugd2hpbGUgcHJpbnRpbmc/ICovXG4gICAgZ2V0IHByaW50QWxpYXMoKTogc3RyaW5nW107XG4gICAgLyoqIExvb2t1cCBicmVha3BvaW50cyBhc3NvY2lhdGVkIHdpdGggcHJpbnQgYWxpYXNlcy4gKi9cbiAgICBnZXQgcHJpbnRCcmVha1BvaW50cygpOiBCcmVha1BvaW50W107XG4gICAgLyoqIExvb2t1cCBicmVha3BvaW50IGFzc29jaWF0ZWQgd2l0aCBtZWRpYVF1ZXJ5ICovXG4gICAgZ2V0RXZlbnRCcmVha3BvaW50cyh7IG1lZGlhUXVlcnkgfTogTWVkaWFDaGFuZ2UpOiBCcmVha1BvaW50W107XG4gICAgLyoqIFVwZGF0ZSBldmVudCB3aXRoIHByaW50QWxpYXMgbWVkaWFRdWVyeSBpbmZvcm1hdGlvbiAqL1xuICAgIHVwZGF0ZUV2ZW50KGV2ZW50OiBNZWRpYUNoYW5nZSk6IE1lZGlhQ2hhbmdlO1xuICAgIHByaXZhdGUgcmVnaXN0ZXJlZEJlZm9yZUFmdGVyUHJpbnRIb29rcztcbiAgICBwcml2YXRlIGlzUHJpbnRpbmdCZWZvcmVBZnRlckV2ZW50O1xuICAgIHByaXZhdGUgYmVmb3JlUHJpbnRFdmVudExpc3RlbmVycztcbiAgICBwcml2YXRlIGFmdGVyUHJpbnRFdmVudExpc3RlbmVycztcbiAgICBwcml2YXRlIHJlZ2lzdGVyQmVmb3JlQWZ0ZXJQcmludEhvb2tzO1xuICAgIC8qKlxuICAgICAqIFByZXBhcmUgUnhKUyBmaWx0ZXIgb3BlcmF0b3Igd2l0aCBwYXJ0aWFsIGFwcGxpY2F0aW9uXG4gICAgICogQHJldHVybiBwaXBlYWJsZSBmaWx0ZXIgcHJlZGljYXRlXG4gICAgICovXG4gICAgaW50ZXJjZXB0RXZlbnRzKHRhcmdldDogSG9va1RhcmdldCk6IChldmVudDogTWVkaWFDaGFuZ2UpID0+IHZvaWQ7XG4gICAgLyoqIFN0b3AgbWVkaWFDaGFuZ2UgZXZlbnQgcHJvcGFnYXRpb24gaW4gZXZlbnQgc3RyZWFtcyAqL1xuICAgIGJsb2NrUHJvcGFnYXRpb24oKTogKGV2ZW50OiBNZWRpYUNoYW5nZSkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTYXZlIGN1cnJlbnQgYWN0aXZhdGVCcmVha3BvaW50cyAoZm9yIGxhdGVyIHJlc3RvcmUpXG4gICAgICogYW5kIHN1YnN0aXR1dGUgb25seSB0aGUgcHJpbnRBbGlhcyBicmVha3BvaW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXJ0UHJpbnRpbmcodGFyZ2V0OiBIb29rVGFyZ2V0LCBicExpc3Q6IE9wdGlvbmFsQnJlYWtQb2ludFtdKTogdm9pZDtcbiAgICAvKiogRm9yIGFueSBwcmludCBkZS1hY3RpdmF0aW9ucywgcmVzZXQgdGhlIGVudGlyZSBwcmludCBxdWV1ZSAqL1xuICAgIHByb3RlY3RlZCBzdG9wUHJpbnRpbmcodGFyZ2V0OiBIb29rVGFyZ2V0KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUbyByZXN0b3JlIHByZS1QcmludCBBY3RpdmF0aW9ucywgd2UgbXVzdCBjYXB0dXJlIHRoZSBwcm9wZXJcbiAgICAgKiBsaXN0IG9mIGJyZWFrcG9pbnQgYWN0aXZhdGlvbnMgQkVGT1JFIHByaW50IHN0YXJ0cy4gT25CZWZvcmVQcmludCgpXG4gICAgICogaXMgc3VwcG9ydGVkOyBzbyAncHJpbnQnIG1lZGlhUXVlcnkgYWN0aXZhdGlvbnMgYXJlIHVzZWQgYXMgYSBmYWxsYmFja1xuICAgICAqIGluIGJyb3dzZXJzIHdpdGhvdXQgYGJlZm9yZXByaW50YCBzdXBwb3J0LlxuICAgICAqXG4gICAgICogPiAgQnV0IGFjdGl2YXRlZCBicmVha3BvaW50cyBhcmUgZGVhY3RpdmF0ZWQgQkVGT1JFICdwcmludCcgYWN0aXZhdGlvbi5cbiAgICAgKlxuICAgICAqIExldCdzIGNhcHR1cmUgYWxsIGRlLWFjdGl2YXRpb25zIHVzaW5nIHRoZSBmb2xsb3dpbmcgbG9naWM6XG4gICAgICpcbiAgICAgKiAgV2hlbiBub3QgcHJpbnRpbmc6XG4gICAgICogICAgLSBjbGVhciBjYWNoZSB3aGVuIGFjdGl2YXRpbmcgbm9uLXByaW50IGJyZWFrcG9pbnRcbiAgICAgKiAgICAtIHVwZGF0ZSBjYWNoZSAoYW5kIHNvcnQpIHdoZW4gZGVhY3RpdmF0aW5nXG4gICAgICpcbiAgICAgKiAgV2hlbiBwcmludGluZzpcbiAgICAgKiAgICAtIHNvcnQgYW5kIHNhdmUgd2hlbiBzdGFydGluZyBwcmludFxuICAgICAqICAgIC0gcmVzdG9yZSBhcyBhY3RpdmF0ZWRUYXJnZXRzIGFuZCBjbGVhciB3aGVuIHN0b3AgcHJpbnRpbmdcbiAgICAgKi9cbiAgICBjb2xsZWN0QWN0aXZhdGlvbnMoZXZlbnQ6IE1lZGlhQ2hhbmdlKTogdm9pZDtcbiAgICAvKiogVGVhcmRvd24gbG9naWMgZm9yIHRoZSBzZXJ2aWNlLiAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqIElzIHRoaXMgc2VydmljZSBjdXJyZW50bHkgaW4gUHJpbnQtbW9kZSA/ICovXG4gICAgcHJpdmF0ZSBpc1ByaW50aW5nO1xuICAgIHByaXZhdGUgcXVldWU7XG4gICAgcHJpdmF0ZSBkZWFjdGl2YXRpb25zO1xufVxuIl19
{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@angular/fire/firestore/observable/fromRef.ts","ng://@angular/fire/firestore/collection/changes.ts","ng://@angular/fire/firestore/collection/collection.ts","ng://@angular/fire/firestore/document/document.ts","ng://@angular/fire/firestore/collection-group/collection-group.ts","ng://@angular/fire/firestore/firestore.ts","ng://@angular/fire/firestore/firestore.module.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","__spread","concat","fromRef","ref","scheduler","rxjs","asyncScheduler","Observable","subscriber","unsubscribe","schedule","onSnapshot","_fromRef","fromDocRef","pipe","map","payload","type","fromCollectionRef","docChanges","query","action","change","sortedChanges","events","changes","scan","current","combineChanges","c","forEach","indexOf","combineChange","combined","newIndex","doc","isEqual","splice","oldIndex","validateEventsArray","AngularFirestoreCollection","afs","stateChanges","schedulers","outsideAngular","actions","filter","keepUnstableUntilFirst","auditTrail","snapshotChanges","validatedEvents","valueChanges","options","docs","a","idField","data","_a","id","get","from","observeOn","insideAngular","add","path","AngularFirestoreDocument","set","update","delete","collection","queryFn","associateQuery","AngularFirestoreCollectionGroup","ENABLE_PERSISTENCE","InjectionToken","PERSISTENCE_SETTINGS","SETTINGS","collectionRef","AngularFirestore","nameOrConfig","shouldEnablePersistence","settings","platformId","zone","persistenceSettings","_this","ɵAngularFireSchedulers","ɵkeepUnstableUntilFirstFactory","firestore","runOutsideAngular","app","ɵfirebaseAppFactory","registerFirestore","firebase","isPlatformServer","persistenceEnabled$","enablePersistence","undefined","then","of","pathOrRef","collectionGroup","collectionId","queryGroupFn","createId","Injectable","args","providedIn","Inject","FIREBASE_OPTIONS","Optional","FIREBASE_APP_NAME","decorators","PLATFORM_ID","NgZone","AngularFirestoreModule","ngModule","providers","provide","useValue","NgModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Observable, SchedulerLike, asyncScheduler } from 'rxjs';\nimport { DocumentReference, Query, Action, Reference, DocumentSnapshot, QuerySnapshot } from '../interfaces';\nimport { map } from 'rxjs/operators';\n\nfunction _fromRef<T, R>(ref: Reference<T>, scheduler: SchedulerLike = asyncScheduler): Observable<R> {\n  return new Observable(subscriber => {\n    let unsubscribe;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot(subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot(subscriber);\n    }\n\n    return function() {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    }\n  });\n}\n\nexport function fromRef<R>(ref: DocumentReference | Query, scheduler?: SchedulerLike) {\n  return _fromRef<typeof ref, R>(ref, scheduler);\n}\n\nexport function fromDocRef<T>(ref: DocumentReference, scheduler?: SchedulerLike): Observable<Action<DocumentSnapshot<T>>>{\n  return fromRef<DocumentSnapshot<T>>(ref, scheduler)\n    .pipe(\n      map(payload => ({ payload, type: 'value' }))\n    );\n}\n\nexport function fromCollectionRef<T>(ref: Query, scheduler?: SchedulerLike): Observable<Action<QuerySnapshot<T>>> {\n  return fromRef<QuerySnapshot<T>>(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n","import { fromCollectionRef } from '../observable/fromRef';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { map, scan } from 'rxjs/operators';\n\nimport { Query, DocumentChangeType, DocumentChange, DocumentChangeAction } from '../interfaces';\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(action =>\n        action.payload.docChanges()\n          .map(change => ({ type: change.type, payload: change } as DocumentChangeAction<T>))));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges<T>(query: Query, events: DocumentChangeType[], scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(changes => changes.payload.docChanges()),\n      scan((current, changes) => combineChanges(current, changes, events), []),\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if(events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch(change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        combined.splice(change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if(change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n","import { Observable, from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan, observeOn } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeType, CollectionReference, Query, DocumentReference, DocumentData, DocumentChangeAction } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if(!events || events!.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T=DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param ref\n   */\n  constructor(\n    public readonly ref: CollectionReference,\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if(!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n      map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n      filter(changes =>  changes.length > 0),\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   * @param options\n   */\n  valueChanges(): Observable<T[]>\n  valueChanges({}): Observable<T[]>\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as Object,\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data()\n          }\n        })),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   * @param path\n   */\n  doc<T>(path?: string): AngularFirestoreDocument<T> {\n    return new AngularFirestoreDocument<T>(this.ref.doc(path), this.afs);\n  }\n}\n","import { Observable, from } from 'rxjs';\nimport { DocumentReference, SetOptions, DocumentData, QueryFn, Action, DocumentSnapshot } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport { firestore } from 'firebase/app';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T=DocumentData> {\n\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param ref\n   */\n  constructor(public ref: DocumentReference, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   * @param data\n   * @param options\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   * @param data\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   * @param path\n   * @param queryFn\n   */\n  collection<R=DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path);\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<R>(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      this.afs.keepUnstableUntilFirst\n    )\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   */\n  valueChanges(): Observable<T|undefined> {\n    return this.snapshotChanges().pipe(\n      map(action => {\n        return action.payload.data();\n      })\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n}\n","import { Observable, from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan, observeOn } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeType, Query, DocumentData, DocumentChangeAction } from '../interfaces';\nimport { validateEventsArray } from '../collection/collection';\nimport { docChanges, sortedChanges } from '../collection/changes';\nimport { AngularFirestore } from '../firestore';\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollectionGroup<T=DocumentData> {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   * @param query\n   * @param afs\n   */\n  constructor(\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if(!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   */\n  valueChanges(): Observable<T[]> {\n    const fromCollectionRefScheduled$ = fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$\n      .pipe(\n        map(actions => actions.payload.docs.map(a => a.data())),\n        this.afs.keepUnstableUntilFirst\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular)\n    );\n  }\n\n}\n","import { InjectionToken, NgZone, PLATFORM_ID, Injectable, Inject, Optional } from '@angular/core';\nimport { Observable, of, from } from 'rxjs';\nimport { Settings, PersistenceSettings, CollectionReference, DocumentReference, QueryFn, Query, QueryGroupFn, AssociatedReference } from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport { FirebaseOptions, FirebaseAppConfig, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵfirebaseAppFactory, ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport { firestore } from 'firebase/app';\nimport firebase from '@firebase/app';\nimport { registerFirestore } from '@firebase/firestore';\nimport 'firebase/firestore';\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const ENABLE_PERSISTENCE = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PERSISTENCE_SETTINGS = new InjectionToken<PersistenceSettings|undefined>('angularfire2.firestore.persistenceSettings');\nexport const SETTINGS = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery(collectionRef: CollectionReference, queryFn = ref => ref): AssociatedReference {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirestore {\n  public readonly firestore: firestore.Firestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   * @param app\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options:FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig:string|FirebaseAppConfig|null|undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean|null,\n    @Optional() @Inject(SETTINGS) settings: Settings|null,\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings|null,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);\n\n    this.firestore = zone.runOutsideAngular(() => {\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n      // INVESTIGATE this seems to be required because in the browser build registerFirestore is an Object?\n      //             seems like we're fighting ngcc. In the server firestore() isn't available, so I have to register\n      //             in the browser registerFirestore is not a function... maybe this is an underlying firebase-js-sdk issue\n      if (registerFirestore) { registerFirestore(firebase) }\n      const firestore = app.firestore();\n      if (settings) { firestore.settings(settings) }\n      return firestore;\n    });\n\n    if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n      // We need to try/catch here because not all enablePersistence() failures are caught\n      // https://github.com/firebase/firebase-js-sdk/issues/608\n      const enablePersistence = () => {\n        try {\n          return from(this.firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n        } catch(e) {\n          return of(false);\n        }\n      };\n      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n    } else {\n      this.persistenceEnabled$ = of(false);\n    }\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   * @param pathOrRef\n   * @param queryFn\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>\n  collection<T>(pathOrRef: string | CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<T>(ref, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   * @param collectionId\n   * @param queryGroupFn\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn): AngularFirestoreCollectionGroup<T> {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup: Query = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   * @param pathOrRef\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>\n  doc<T>(pathOrRef: string | DocumentReference): AngularFirestoreDocument<T> {\n    let ref: DocumentReference;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n    return new AngularFirestoreDocument<T>(ref, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { PersistenceSettings } from './interfaces';\nimport { AngularFirestore, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS } from './firestore';\n\n@NgModule({\n  providers: [ AngularFirestore ]\n})\nexport class AngularFirestoreModule {\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings?: PersistenceSettings): ModuleWithProviders {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [\n        { provide: ENABLE_PERSISTENCE, useValue: true },\n        { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n      ]\n    }\n  }\n}\n"]}